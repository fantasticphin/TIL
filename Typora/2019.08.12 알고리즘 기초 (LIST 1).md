# 2019.08.12 알고리즘 기초 (LIST 1)

개발 단계 : **<u>1. 요구사항 분석 2. 설계 3. 구현 4.헤스트 5. 유지보수</u>**

*Intermediate 은 반복문(For)로 풀 수 있다.*

*Advanced는 완전검색(가지치기, 재귀함수)* DFS - 재귀함수

코딩 전, 설계와 연필로 작성해보고 하자

**알고리즘** : *유한한* 단계 통해 문제를 *해결하기* 위한 *절차/방법.*

*문제를 해결하기 위한 절차



컴퓨터 알고리즘 : 1.슈더코드(Pseudocode) 2. 순서도(order)



좋은 알고리즘 요소:

1. **정확성** 2. **작업량** 3. **메모리 사용량** 4. **단순성** 5. **최적성**



알고리즘 성능은 -> 시간 복잡도(실제 걸리는 시간) <=> 빅-오 표기법

O(logn) : 이진 탐색

- 기본적 정렬 상태 1 부터 100 사이 숫자에서 up,down 으로 찾는 과정 -> log100 => 6~7번 돌려서 찾음

  P 알고리즘 (다항식)

- O(n): 순차 탐색

- O(logn): 퀵소트, 병합, heap

- O(n^2) : 선택, 버블, 삽입 정렬

  NP 알고리즘 -> 최단거리

- NP- O(2^n) : 부분집합

  ​			O(n!) : 순열

배열 (Array) ; 파이썬은 list

list는 for 문과 함께 쓰면 의미가 있다.



완전검색 : 문제 해법의 **모든 경우의 수를 나열,** <u>확인</u>하는 기법

- 완전검색의 가지치기하는 것이 백트랙킹, 완전검색은 재귀를 할 줄 알아야 함

* brute-force // generate and test
* 경우의 **수가** 상대적으로 **적을** **때** <u>유용</u>
* 수행 속도느리지만, 해답 찾을 확률 높음

탐욕 알고리즘 : 최적해를 구하는 근시안적인 방법

1. 순간별 최적이라고 생각해 최종적 해답에 도달
2.  각 순간 결정 -> 지역적 최적, 계속 수집해 해답을 만들어도 최적 이라는 보장 X
3. 머릿속에 떠오르는 생각 w/o 검증 -> 바로 구현 ->  greedy

## 탐욕 알고리즘 예시

거스름돈 나눠주기 (최적화 ) :

가장 큰 거스름돈인 (500원) 을 많이 반환하여 갯수를 줄이려고 함.

혹여나 400원 짜리가 있어도 500원을 선택하게 됌. (500원이 더 크니 적은 개수를 의미하기 때문)



code

data : 전역변수

heap : 리스트, 배열

stack : 변수, 만일 재귀호출하면 변수가 스텍에 쌓임



## 정렬의 종류

- 버블 종류 (가벼운게 위로 뜬다 에서 유래)

  - 첫 번째 원소부터 인접한 원소끼리 계속 자리를 교환하며 마지막 자리까지 이동
  - 한 단계가 끝나면 가장 큰 원소가 마지막 자리에 정렬
  - 교환하며 자리를 이동하는 모습이 물 위에 올라오는 거품 모양 같아서 유래...
  - O(n2) -> 시간복잡도

  *교환(swap) : 파이썬은 a[j], a[j+1] = a[j+1], a[j]

  하지만 통상은 이렇게 진행되어야함:

  ```python
  def BubbleSort(a):
      for i in range(len(a)-1, 0, 1):
          for j in range(0, 1):
              if a[j] > a[j+1]:
                  a[j], a[j+1] = a[j+1], a[j] 
  print(BubbleSort())
  
  자리 바꾸기 (swap)
  temp = a[j]
  a[j] = a[j+1]
  a[j+1] = temp
  ```

  

- 카운팅

  - 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하고, 선형 시간에 정렬하는 효율적 알고리즘

  - 제한 사항 : 정수나 정수로 표현할 수 있는 자료에 대해서만 적용 가능 // 그 이유는 각 항목의 발생 회수 기록을 위해 정수 항목으로 인덱싱 되는 카운트들의 배열을 사용하기 때문이다.

  - 시간 복잡도 :  O(n+k): n은 리스트 길이, k는 정수의 최댓값

  - ascii 코드 설명:

    0~127 // 65 ='A', 97 = 'a' // byte = 영문자 한 개를 나타낼 수 있는 수

    1 Byte = 8bit // 1개는 패리티 비트, 비트의 개수가 짝수면 마지막 비트로 0, 홀수이면 1을 붙여서 에러체크하는 비트

  - 한글을 나타내는 코드는 유니코드 (16bit = 2Byte)

  - 유니코드는 ASCII도 포함하고 있다.  

  - $$
    2^(16)
    $$

  - 한글은 조합형, 유니코드는 완성형, [가~힣] => 1만 1천자가 들어가 있다.

  - 많다 그래서 문자열은 quick sort 를 사용

- 선택
- 퀵
- 삽입
- 병합

# 알고리즘 기초 (LIST 2)

**2차원 배열 선언**

: 1차원 list를 묶어놓은 리스트, 2차원 이상의 다차원 list는 차원에 따라 index 선언

**2차원 리스트 선언**

: 세로길이 (행 개수) 가로길이(열 개수)

**파이썬 메리트**

: 데이터 초기화를 통해 변수선언과 초기화가 가능함



```python
2차원 배열 작성
 row, col = map(int, input().split()) #2차원 배열일 때 가로 세로 길이를 준다
    data = [[0 for _ in range(col)] for _ in range(row)]
    data = [list(map(int, input().split())) for _ in range(row)] #방법 1
    print(data)
    
    for i in range(row): #방법 2
    data[i] = list(map(int, input().split())) #방법 2
    for i in range(row):
    for j in range(col):
    print(data[i][j], end=" ")
    print()
```



**배열 순회**

: n X m 배열의 n*m 개의 모든 원소를 빠짐없이 조사하는 방법



**<u>행 우선 순회</u>**

i 행의 좌표, j 행의 좌표

for i in range(len(Array)):

​	for j in range(len(Array[i])):

​		Array I J <-- 필요한 연산 수행



**<u>열 우선 순회</u>**

i 행의 좌표, j 열의 좌표

for j in range(len(Array[0])):

​	for i in range(len(Array)):

​		Array I J <-- 필요한 연산 수행



델타 검색

: 2차 배열의 한 좌표에서 4 방향의 인접 배열 요소를 탐색하는 방법

```python
dx = [0,0,-1,1] +[-1,1,1,-1] <- 8방향일 때 뒷 4요소 추가
dy = [-1,1,0,0] +[-1,-1,1,1] <- 8방향일 때 뒷 4요소 추가
newdx = x + dx[i]
newdy = y + dx[j]
```



전치 행렬

:방향감이 없는 그래프에서 거리를 구할 때 쓰기 유용한 행렬

```python
i : 행의 좌표, len(arr)
j : 열의 좌표, len(arr[0])
arr = [[1,2,3], [4,5,6], [7,8,9]] #3x3 행렬

for i in range(3):
    for j in range(3):
        if i < j:
            arr[i][j], arr[j][i] = arr[j][i], arr[i][j]
```



**<u>부분 집합</u>**



```python
def printList(data, bit):
   for i in range(len(bit)):
       if bit[i]: print(data[i], end=" ")
   print()

data = [1,2,3]
bit = [0, 0, 0, 0]
for i in range(2):
    bit[0] = i
    for j in range(2):
        bit[1] = j
        for k in range(2):
            bit[2] = k
            for l in range(2):
                bit[3] = l
                print(data, bit)
```

비트 연산자

```python
& 비트 단위로 and 연산을 함
| 비트 단위로 or 연산을 함
<< 피연산자의 비트 열을 좌측으로 이동
>> 피연산자의 비트 열을 우측으로 이동

1<<n: 2n(승), 즉 원소가 n개일 경우 모든 부분집합의 수를 의미
& 연산자
i & (1<<j): i의 j번째 비트가 1인지 아닌지를 리턴함.
^ 기호는 익스쿨루시브 XOR 을 뜻 함. 서로 다를 때 1을 반환함

비트 연산자 예시
arr = [1,2,3]
n = len(arr) # 원소의 개수

for i in range(1 << n): 부분 집합의 개수
    for j in range(n): 원소의 수만큼 비트를 비교함
        if i & (1<<j): i의 j번째 비트가 1이면 j번째 원소 출력
            print(arr[j], end=',')
    print()
print()

1,
2,
1,2,
3,
1,3,
2,3,
1,2,3,

```



검색

: 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업

: 목적하는 탐색 키를 가진 항목을 찾는 것 -> 탐색 키(search key): 자료를 구별하여 인식할 수 있는 키

1. **순차 검색** : 
   - 가장 간단, 직관적 방법 // 배열 혹은 리스트 등 순차적 구조로 구현된 자료에서 원하는 항목 찾기
   - 단순,쉬운 구현 // 검색 대상 만흐면 수행시간 급격 증가, 비효율적

2. **이진 검색:**

   - 자료의 중간에 있는 항목의 키 값과 비교해 다음 검색 위치를 결정하고 검색을 계속 진행하는 방법

   - 목적 키를 찾을 때 까지 이진 검색을 순환적으로 반복 수행, 검색 반위 반으로 줄어 빠르게 검색 수행

   - 자료가  꼭 **<u>정렬되어야</u>** 한다!

   - 검색 과정 -> 자료 중앙 원소 선택 -> 찾는 목표 값 비교 -> 목표값이 중앙원소 보다 작으면 좌측반 ----->

     목표값이 중앙원소보다 크면 우측 반으로 검색

3. **해쉬**



**인덱스**

: database 에서 유래, 테이블 동작 속도 향상 시켲는 자료 구조, db가 아닌 곳에서는 look up table 용어 사용

: 인덱스 저장에 필요한 디스크 공간은 통상 테이블을 저장, 필요 디스크 공간보다 작음 <- 이유는 인덱스는 

키&필드만 가지고, 테이블의 다른 세부 항목을 갖고 있지 않음

배열 사용 인덱스 : 대량 데이터 성능 저하 문제 해결을 위해 배열 인덱스 사용.



**셀렉션 알고리즘**

: 저장된 자료로부터 k 번쨰로 큰 혹은 작은 원소를 찾은 방법

: 최대 최소값 혹은 중간값을 찾는 알고리즘을 의미



**선택 정렬**

: 주어진 자료에서 최소값 원소부터 차례로 선택해 위치를 교환함

과정 -> 리스트 최소값 확인 -> 리스트 맨 앞 위치와 교환 -> 맨 처음 위치 제외한 나머지 리스트 대상 위 과정 반복

# 알고리즘 기초 (문자열, string)



# 알고리즘 기초(스택 1, 2)



# 알고리즘 기초 큐 (Queue)



# 알고리즘 기초(리스트)



# 알고리즘 기초 트리

